# 概要

このゲームは「Wii Party 花さかロジック」風の“スタート位置（＋初期向き）当て”パズルを、2D タイルベース・ターン制シミュレーションで実装するミニゲームです。クリアまで盤面は固定で、失敗したら駒だけ配置前に戻して再挑戦します。

概要
ジャンル：タイルベース 2D の論理パズル（展示向け・短時間プレイ想定）

コンセプト：用意された盤面に、向きが決まった駒（プレイヤー）を配置すると自動で進み、全ゴールを埋められる配置を当てる

実装方針：盤面は 2D 配列（BoardState）で保持し、表示は TileMap へ投影する（TileMap はセル単位で描画できる）
​
ゲームループ
PLACEMENT：画面端のインベントリに「初期向き付きの駒（32×32）」が並び、マウス操作だけで通常マスへ全駒を配置する

全駒が置かれたら自動で SIMULATION：ターン制（1 ステップで全員が同時に 1 マス進む）で進行し、矢印・ワープ・衝突・奈落・ゴールなどの効果を処理する

RESULT：クリアなら次の問題へ、失敗なら同じ盤面のまま駒だけインベントリに戻して再挑戦

ルール要素（MVP）
タイル：通常／矢印（方向変更）／ゴール（停止）／ワープ（ペア移動）

プレイヤー：区別なし。ただし各駒は初期方向（上下左右）が固定で、配置時点から見た目で分かる

判定：全ゴールが埋まったらクリア／奈落落下や詰み（全停止で未達、ループ）で失敗

展示運用（アトラクト/放置）
無操作が一定時間続いたら「続けますか？」を表示し、さらに無操作が続けばアトラクトモード（自動デモ）へ遷移する

アトラクトは展示で興味を引くためのデモ表示として一般的な概念なので、ゲーム内状態（ATTRACT）として持つ方針で進める
​
状態管理は、ATTRACT / PLACEMENT / SIMULATION / RESULT / GAME_OVER などの状態機械で整理する
​

# 環境

- `python uv`
- `pygame`

# 大まかな分類・流れ

## ゲームの開始と終了

```
デフォルト状態：アトラクトモード（自動デモ）
↓
↓:マウスを動かすとタイトルへ
↓
タイトル：タイトル表示
↓
↓:数秒経ったらプレイへ
↓
プレイ：ゲームプレイ
↓
↓:マウス操作が１分以上無かったら、「プレイを続けますか？(マウスを動かすと続行)」表示
↓
↑:マウス操作があったらプレイ続行
↓
↓:マウス操作がその後１０秒以上無かったらアトラクトへ
↓
デフォルト状態：アトラクトモード（自動デモ）
```

## ゲームプレイ

```
ステージ１：JSON ファイルからステージデータを読み込みステージを表示
↓
↓：全駒を配置されるまで待機
↓
↓：全駒を配置したらシミュレーションへ
↓
シミュレーション：全駒をターン制シミュレーションで進行
↓
↓：全ゴールを埋めたら次のステージへ
↓
↑：全ゴールを埋めなかったら、全駒の配置を元に戻してリセットし、全駒を配置するまで待機
↓
次のステージ：次のステージへ
↓
ゲームクリア：すべてのステージをクリアしたらゲームクリア!!!
```

## 開発者モードへ移行

```
開発者モード：キーボードの「D」を押すと開発者モードへ
↓
開発者モード：マップのランダム生成、マップの保存を行い、ステージの追加に活用
↓
アトラクトに戻る：開発者モードで「D」を押すとアトラクトモードへ
```

## 開発者モード

- 入力欄を配置して、マップの縦横、ゴールの数、ゴールの座標（任意）、プレイヤーの向き（任意）、プレイヤーの座標（任意）などを指定できる入力欄を配置する。
- 入力欄の内容を元にマップを生成する。シミュレーションでクリア可能でなければ、再生成する。
- 生成したマップを保存するボタンを配置。保存したマップは、ステージの追加に活用する。

## アトラクトモード

- 自動でデモを表示する。
- アトラクト用のステージを表示する。
- 自動で駒を配置する。
- 自動でシミュレーションを進行する。
- 自動で全ゴールを埋めたら次のアトラクト用ステージへ。
- デモプレイのためユーザー操作があるまで無限ループする。
- ユーザー操作があったらプレイへ遷移する。

# 仕様

## タイル・マス

- 奈落:id-00100: プレイヤーが落ちると失敗 → リセット
- 通常:id-00200: 駒を置けるマス
- ゴール:id-00300: プレイヤーが到達すると止まる。全ゴールを埋めたらクリア
- 上矢印:id-00400: プレイヤーの向きを上に変更
- 下矢印:id-00500: プレイヤーの向きを下に変更
- 右矢印:id-00600: プレイヤーの向きを右に変更
- 左矢印:id-00700: プレイヤーの向きを左に変更
- ワープ:id-00800: プレイヤーが到達すると同じ id ペアのマスへテレポート。同じ id は 2 つ。

タイル・マスは、id で識別する。3 桁でタイルの種類を表す。その後 2 桁で分類が必要な場合は分類を表す。例えばワープマスを 2 セット配置する場合は、id-00800 を２つと id-00801 を２つ配置することで、それぞれ異なるワープペアを配置することができる。

## プレイヤー

- プレイヤー駒は初期方向（上下左右）が固定で、インベントリから見た目で分かる。
- ユーザーはプレイヤー駒を通常マスに配置することができる。何度でも配置を変更することができる。
- 全てのプレイヤー駒が通常マスに配置されると、自動でシミュレーションへ遷移する。

## マップデータ形式

**ファイル**

- JSON 形式
- ファイル名: `root/stages/{stage_level}.json`

マップデータは JSON 形式で、ステージのマップデータを表す。ファイルは`root/stages`フォルダに配置する。ゲームプレイでは、`root/stages`フォルダからステージごとにマップデータを読み込む。
開発者モードで保存したマップデータは、`root/create_stage`フォルダに保存される。

**JSON 内のデータ**

- マップのタイルの ID の二次元配列
- プレイヤーの数と向きと答えの座標

JSON ファイル内には、これらのデータを保持する。これにより、ゲームプレイでは、マップデータを読み込むことができる。また、開発者モードで保存するマップデータも、この形式で保存される。

**例**

```json
{
  "map_data": [
    ["00200", "00200", "00200", "00200", "00200"],
    ["00200", "00200", "00200", "00200", "00200"],
    ["00200", "00200", "00300", "00200", "00200"],
    ["00100", "00100", "00100", "00100", "00100"],
    ["00200", "00200", "00200", "00200", "00300"]
  ],
  "players": [
    {
      "direction": "down",
      "answer": {
        "x": 2,
        "y": 0
      }
    },
    {
      "direction": "right",
      "answer": {
        "x": 0,
        "y": 4
      }
    }
  ]
}
```

## コード構造

- このゲームのコードは main.py を唯一のエントリーポイントとして、ゲームプレイと開発者モードどちらも切り替えられるように構築する。
- コードは src フォルダに配置する。
- コードは保守性、可読性、拡張性などを考慮して SRP などの設計原則を遵守する。

## タイル・マス画像ファイル

- タイル・マス画像ファイルは `root/img/` フォルダに配置する。

# 開発手順

以下の手順に沿って開発を行う。

## 開発ステップ１

このステップでは、基本的なゲーム構造を構築する。
アプリケーションのエントリーポイントとなる main.py を作成する。
アプリを起動すると、現在のモードを右上に表示して各状態遷移が可能にする。
まずは状態遷移のテストのため、右上の表示を変更するだけにする。ほかには何もしない。
状態遷移の条件は上記の仕様の通りに実装する。

- アトラクトモード
- プレイモード
- 開発者モード

仕様では、切り替えでマウスの移動を判定するが、展示運用では、人が歩く振動で誤検知する可能性があるため、マウスの移動量が一定値を超えたときにのみ状態遷移を行うことで、誤検知を防ぐ。

---
